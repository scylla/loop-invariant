(** Representing equation system *)

open Format;;
open Lexing;;

(*  ********************************************************************* *)
(** {2 Hypergraphs *)
(*  ********************************************************************* *)

(** A variable in an equation = a control point *)
type vertex = Cil_types.location

(** A function in an equation: identified by an integer *)
type hedge = int(*use Cil_types.stmt.sid??*)

let compare_point (a:Cil_types.location) (b:Cil_types.location) =
	let (a1,a2) = a in
	let (b1,b2) =b in
  a1.pos_lnum - b1.pos_lnum

let equal_point (a:Cil_types.location) (b:Cil_types.location) =
	let (a1,a2) = a in
	let (b1,b2) =b in
  (a1.pos_lnum  == b1.pos_lnum )

let hash_point (x:Cil_types.location) =
	let (x1,x2) = x in
  abs x1.pos_lnum


let vertex_dummy = (dummy_pos,dummy_pos)
let hedge_dummy = -1

let compare = {
  PSHGraph.hashv = {
    Hashhe.hash = hash_point;
    Hashhe.equal = equal_point;
  };
  PSHGraph.hashh = {
    Hashhe.hash = (fun x -> abs x);
    Hashhe.equal = (==)
  };
  PSHGraph.comparev = compare_point;
  PSHGraph.compareh = (-)
}

let create n info = PSHGraph.create compare n info

(*  ********************************************************************* *)
(** {2 Preprocessed information} *)
(*  ********************************************************************* *)

(** Useful information associated to a procedure *)
type procinfo = {
	kf : Cil_types.kernel_function;
  pname : string;        (** Procedure name *)
  pstart: Cil_types.location; (** Procedure start point *)
  pexit: Cil_types.location;  (** Procedure exit point *)
  pinput: Apron.Var.t array;  (** Array of input variables *)
  plocal: Apron.Var.t array;  (** Array of other variables *)
  penv: Apron.Environment.t;  (** Environment of the procedure *)
}

(** Useful information for the program *)
type info = {
  procinfo : (string, procinfo) Hashhe.t;
    (** Hashtable [procedure name -> procinfo].
	Main procedure has empty name *)
  callret : (Cil_types.location,Cil_types.location) DHashhe.t;
    (** Two-way association call points/return points generated by procedure
      calls. *)
  pointenv : (Cil_types.location,Apron.Environment.t) Hashhe.t;
    (** Hashtable [point -> environment of the enclosing procedure]. *)
  mutable counter : int;
    (** Last free hyperedge identifier (used by [add_equation]). *)
}

(*  ********************************************************************* *)
(** {2 Equation system} *)
(*  ********************************************************************* *)

(** A variable in an equation = a control point *)
type var = Cil_types.location

(** Information associated to hyperedges/functions used in equations *)
type transfer =
  | Lassign of Apron.Var.t * Apron.Linexpr1.t
      (** Assignement by a linear expression *)
  | Tassign of Apron.Var.t * Apron.Texpr1.t
      (** Assignement by a tree expression *)
  | Condition of Apron.Tcons1.earray Boolexpr.t
      (** Filtering of a predicate by a Boolean expression *)
  | Call of procinfo * procinfo * (Apron.Var.t array) * (Apron.Var.t array)
      (** Procedure call, of the form
	  [Call(callerinfo,calleeinfo,actual input parameters,actual
	  output parameters)] *)
  | Return of procinfo * procinfo * (Apron.Var.t array) * (Apron.Var.t array)
      (** Procedure return, of the form
	  [Call(callerinfo,calleeinfo,actual input parameters,actual
	  output parameters)] *)

(** Equation system, represented by a graph, where vertex
    identifiers are control point, and hyperedge identifiers are
    integers, with which are associated objects of type
    [transfer]. Global information associated with the graph is of
    type [info]. *)
type graph = (Cil_types.location,hedge,unit,transfer,info) PSHGraph.t

(*  ********************************************************************* *)
(** {2 Functions} *)
(*  ********************************************************************* *)

(** Adding an equation *)
let add_equation (graph:graph) (torg:var array) (transfer:transfer) (dest:var):unit =
  Array.iter
    (begin fun var ->
      if not (PSHGraph.is_vertex graph var) then PSHGraph.add_vertex graph var ()
    end)
    torg
  ;
  if not (PSHGraph.is_vertex graph dest) then PSHGraph.add_vertex graph dest ();
  if transfer<>(Condition(Boolexpr.DISJ([]))) then begin
    let info = PSHGraph.info graph in
    PSHGraph.add_hedge graph info.counter transfer ~pred:torg ~succ:[|dest|];
    info.counter <- info.counter + 1;
  end;
  ()
